### [Python Object-Oriented Programming - Fourth Edition](https://learning.oreilly.com/library/view/python-object-oriented-programming/9781801077262/)
- [簡體中譯本:Python 面向對象編程, 4/e](https://www.tenlong.com.tw/products/9787121483240?list_name=trs-t)
- [Github](https://github.com/PacktPublishing/Python-Object-Oriented-Programming---4th-edition)


## 1章 物件導向設計 1
```
1.1 物件導向簡介 1
1.2 對象和類 3
1.3 定義屬性和行為 6
1.3.1 用資料描述物件的狀態 6
1.3.2 行為就是動作 9
1.4 隱藏細節並創建公共介面 10
1.5 組合 13
1.6 繼承 16
1.6.1 繼承提供抽象 19
1.6.2 多重繼承 19
1.7 案例學習 21
1.7.1 簡介和問題概述 22
1.7.2 上下文視圖 24
1.7.3 邏輯視圖 27
1.7.4 過程視圖 29
1.7.5 開發視圖 31
1.7.6 物理視圖 33
1.7.7 結論 34
1.8 回顧 35
1.9 練習 35
1.10 總結 36
```
## 2章 Python的對象 37
```
2.1 類型提示 37
2.2 創建Python的類 43
2.2.1 添加屬性 44
2.2.2 讓它做點什麼 45
2.2.3 初始化對象 49
2.2.4 類型提示和預設值 52
2.2.5 使用文檔字串 53
2.3 模組(module)和套件(package) 56
2.3.1 組織模組 59
2.3.2 組織模組內容 63
2.4 誰可以訪問我的資料 68
2.5 協力廠商函數庫 69
2.6 案例學習 72
2.6.1 邏輯視圖 72
2.6.2 樣本和狀態 74
2.6.3 樣本狀態轉換 75
2.6.4 類的職責 80
2.6.5 TrainingData類 81
2.7 回顧 85
2.8 練習 85
2.9 總結 86
```
## 第3章 當物件相似時 87
```
3.1 基本繼承 88
3.1.1 擴展內置物件 91
3.1.2 重寫和super 94
3.2 多重繼承 96
3.2.1 鑽石型繼承問題 100
3.2.2 不同集合的參數 107
3.3 多態 110
3.4 案例學習 114
3.4.1 邏輯視圖 115
3.4.2 另一種距離演算法 120
3.5 回顧 122
3.6 練習 122
3.7 總結 123
```
## 第4章 異常捕獲 124
```
4.1 拋出異常 125
4.1.1 拋出一個異常 127
4.1.2 異常的作用 129
4.1.3 處理異常 131
4.1.4 異常的層級 138
4.1.5 定義我們自己的異常 139
4.1.6 異常並不是例外 142
4.2 案例學習 146
4.2.1 上下文視圖 147
4.2.2 過程視圖 148
4.2.3 什麼可能出錯 149
4.2.4 錯誤的行為 150
4.2.5 通過CSV檔創建樣本 151
4.2.6 驗證枚舉值 155
4.2.7 讀取CSV文件 157
4.2.8 不要重複你自己 159
4.3 回顧 160
4.4 練習 161
4.5 總結 162
```
## 第5章 何時使用物件導向程式設計 163
```
5.1 將物件看作物件 163
5.2 通過屬性向類資料添加行為 170
5.2.1 屬性的細節 173
5.2.2 裝飾器——另一種創建屬性的方法 176
5.2.3 決定何時使用屬性 177
5.3 管理器物件 180
5.3.1 刪除重複的代碼 186
5.3.2 實踐 188
5.4 案例學習 192
5.4.1 輸入驗證 192
5.4.2 輸入分塊 195
5.4.3 樣本的類層級 196
5.4.4 purpose枚舉類 198
5.4.5 Property setters 201
5.4.6 重複的if語句 201
5.5 回顧 202
5.6 練習 202
5.7 總結 203
```
## 第6章 抽象基類和運算子重載 204
```
6.1 創建抽象基類 206
6.1.1 collections模組中的抽象基類 208
6.1.2 抽象基類和類型提示 211
6.1.3 collections.abc模組 212
6.1.4 創建自己的抽象基類 219
6.1.5 揭開魔法的神秘面紗 224
6.2 運算子重載 225
6.3 擴展內置類 232
6.4 元類 235
6.5 案例學習 241
6.5.1 用兩個子列表擴展list類 241
6.5.2 分割的洗牌策略 244
6.5.3 分割的增量策略 246
6.6 回顧 249
6.7 練習 250
6.8 總結 251
```
## 第7章 Python的資料結構 252
```
7.1 空對象 252
7.2 元組和命名元組 254
使用typing.NamedTuple的命名元組 257
7.3 數據類 260
7.4 字典 264
7.4.1 字典的用例 270
7.4.2 使用defaultdict 271
7.5 列表 275
列表排序 278
7.6 集合 285
7.7 3種佇列 289
7.8 案例學習 293
7.8.1 邏輯模型 294
7.8.2 凍結的數據類 297
7.8.3 NamedTuple類 300
7.8.4 結論 303
7.9 回顧 304
7.10 練習 304
7.11 總結 306
```
## 第8章 物件導向程式設計和`函數式程式設計(Functional Programming)` 
```
8.1 Python的內置函數 307
8.1.1 len()函數 308
8.1.2 reversed()函數 309
8.1.3 enumerate()函數 310
8.2 方法重載的另一種方式 312
8.2.1 參數的預設值 314
8.2.2 可變參數列表 319
8.2.3 參數解包 326
8.3 函數也是物件 328
8.3.1 函數物件和回呼函數 330
8.3.2 用函數給類打補丁 336
8.3.3 可調用物件 338
8.4 文件I/O 340
把它放在上下文中 343
8.5 案例學習 348
8.5.1 處理概述 348
8.5.2 分割數據 350
8.5.3 重新思考分類 351
8.5.4 partition()函數 354
8.5.5 一次性分割 355
8.6 回顧 358
8.7 練習 359
8.8 總結 360
```
## 第9章 字串、序列化和檔案路徑 361
```
9.1 字串 362
9.1.1 字串操作 363
9.1.2 字串格式化 366
9.1.3 字串是Unicode 377
9.2 規則運算式 383
9.2.1 模式匹配 385
9.2.2 用規則運算式解析資訊 394
9.3 檔案系統路徑 398
9.4 序列化物件 402
9.4.1 定制pickle 405
9.4.2 用JSON序列化物件 408
9.5 案例學習 411
9.5.1 CSV格式設計 412
9.5.2 CSV字典閱讀器 413
9.5.3 CSV列表閱讀器 416
9.5.4 JSON序列化 418
9.5.5 用分行符號分隔的JSON 420
9.5.6 JSON驗證 421
9.6 回顧 424
9.7 練習 424
9.8 總結 426
```
## 10章 反覆運算器模式 427
```
10.1 設計模式簡介 427
10.2 反覆運算器 428
反覆運算器協議 429
10.3 推導式 432
10.3.1 列表推導式 432
10.3.2 集合和字典推導式 435
10.3.3 生成器運算式 436
10.4 生成器函數 439
10.4.1 通過另一個可反覆運算物件產生元素 444
10.4.2 生成器堆疊 446
10.5 案例學習 450
10.5.1 相關集合知識 451
10.5.2 多分區 452
10.5.3 測試 457
10.5.4 基本的KNN演算法 459
10.5.5 使用bisect模組的KNN 460
10.5.6 使用headq模組的KNN 462
10.5.7 結論 462
10.6 回顧 465
10.7 練習 465
10.8 總結 467
## 11章 通用設計模式 468
11.1 裝飾器模式 469
11.1.1 裝飾器模式示例 470
11.1.2 Python中的裝飾器 478
11.2 觀察者模式 482
觀察者模式示例 483
11.3 策略模式 487
11.3.1 策略模式示例 488
11.3.2 Python中的策略模式 492
11.4 命令模式 493
命令模式示例 494
11.5 狀態模式 499
11.5.1 狀態模式示例 500
11.5.2 狀態模式與策略模式 508
11.6 單例模式 509
單例模式的實現 510
11.7 案例學習 515
11.8 回顧 524
11.9 練習 525
11.10 總結 526
## 12章 *級設計模式 527
12.1 適配器模式 527
適配器模式示例 529
12.2 面板模式 533
面板模式示例 534
12.3 享元模式 538
12.3.1 Python中的享元模式示例 540
12.3.2 包含多條消息的緩衝區 547
12.3.3 使用Python的__slots__優化記憶體 549
12.4 抽象工廠模式 551
12.4.1 抽象工廠模式示例 552
12.4.2 Python中的抽象工廠模式 558
12.5 組合模式 559
組合模式示例 561
12.6 範本模式 567
範本模式示例 568
12.7 案例學習 574
12.8 回顧 577
12.9 練習 577
12.10 總結 579
```
## 13章 測試物件導向的程式 580
```
13.1 為什麼要測試 580
13.1.1 測試驅動開發 582
13.1.2 測試目標 583
13.1.3 測試模式 584
13.2 使用unittest進行單元測試 586
13.3 使用pytest進行單元測試 588
13.3.1 pytest的設置和清理函數 591
13.3.2 pytest用於設置和清理的fixture 594
13.3.3 更高階的fixture 599
13.3.4 用pytest跳過測試 606
13.4 使用Mock類比物件 608
13.4.1 其他打補丁技術 612
13.4.2 sentinal對象 615
13.5 進行多少測試才是足夠的 617
13.6 開發和測試 621
13.7 案例學習 622
13.7.1 距離演算法類的單元測試 623
13.7.2 Hyperparameter類的單元測試 629
13.8 回顧 633
13.9 練習 634
13.10 總結 636
```
## 14章 併發(Concurrency)
```
併發處理的背景 638
14.1 執行緒 640
執行緒的許多問題 642
14.2 多進程 644
14.2.1 多進程池 647
14.2.2 佇列 651
14.2.3 多進程的問題 656
14.3 future 657
14.4 AsyncIO 662
14.4.1 AsyncIO實戰 663
14.4.2 讀取AsyncIO future 665
14.4.3 網路AsyncIO 666
14.4.4 日誌編寫演示 674
14.4.5 AsyncIO用戶端 677
14.5 哲學家用餐問題 681
14.6 案例學習 685
14.7 回顧 690
14.8 練習 690
14.9 總結 692  
```
